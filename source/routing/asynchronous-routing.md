Этот раздел рассказывает о продвинутых функциях роутера и его возможности обрабатывать сложную асинхронную логику внутри приложения.

### Пара слов об обещаниях…

Подход Ember к обработке асинхронной логики в роутере усложняет использование концепции обещаний. Обещания — объекты, которые представляют значение события. Обещание может завершиться успешно (разрешить значение) или с ошибкой (не разрешить значение). Чтобы вернуть это конечное значение или обработать случаи, когда обещание завершается с ошибкой, нужно использовать метод обещания [`then()`](http://emberjs.com/api/classes/Ember.Route.html#method_setupController). Он принимает два опциональных обратных вызова: один для успешного завершения и один для выполнения с ошибкой. Если обещание завершается успешно, то запускается обработчик выполнения с соответствующим значением в качестве единственного аргумента. Если возникает ошибка, вызывается обработчик отказа с указанием причины ошибки в качестве единственного аргумента. Например:

```js
var promise = fetchTheAnswer();

promise.then(fulfill, reject);

function fulfill(answer) {
  console.log('The answer is ' + answer);
}

function reject(reason) {
  console.log(`Couldn't get the answer! Reason: ${reason}`);
}
```

В целом эффективность обещаний строится на том, что их можно объединять в цепочку для выполнения последовательных асинхронных операций:

```js
// Note: jQuery AJAX methods return promises
var usernamesPromise = Ember.$.getJSON('/usernames.json');

usernamesPromise.then(fetchPhotosOfUsers)
                .then(applyInstagramFilters)
                .then(uploadTrendyPhotoAlbum)
                .then(displaySuccessMessage, handleErrors);
```

В примере выше, если какой-то из методов `fetchPhotosOfUsers`, `applyInstagramFilters` или `uploadTrendyPhotoAlbum` возвращает завершенное с ошибкой обещания, будет вызван `handleErrors` с причиной ошибки. Обещания схожи с асинхронной формой операторов обработки исключений тем, что не допускают «смещения вправо» вложенного обратного вызова после вложенного обратного вызова и обеспечивают разумный подход к управлению сложной асинхронной логикой в приложении.

Это руководство полностью не раскрывает все способы использования обещаний, но если вы хотите больше о них узнать, то почитайте о библиотеке обещаний [RSVP](https://github.com/tildeio/rsvp.js), которая используется в Ember.

### Паузы роутера для обещаний

При переходе между маршрутами роутер Ember собирает все модели (через hook `model`), которые будут переданы контроллерам маршрута в конце перехода. Если hook `model` (или связанные hooks `beforeModel` или `afterModel`) возвращают нормальные (без обещания) объекты или массивы, переход завершится сразу. Но если hook `model` (или связанные hooks `beforeModel` или `afterModel`) возвращает обещание (или если обещание выступало в качестве аргумента к `transitionTo`), переход будет приостановлен, пока это обещание не завершится успешно или с ошибкой.

Роутер рассматривает любой объект с методом `then()` как обещание.

Если обещание завершается успешно, переход продолжается с места остановки и начинает разрешать следующую модель (потомка) маршрута. Он остановится, если снова встретит обещание, и так далее, пока не будут разрешены все модели маршрута назначения. Значения, которые переданы hook [`setupController()`](http://emberjs.com/api/classes/Ember.Route.html#method_setupController) для каждого маршрута, будут разрешенными значениями из обещаний.

Базовый пример:

`app/routes/tardy.js`
```js
export default Ember.Route.extend({
  model() {
    return new Ember.RSVP.Promise(function(resolve) {
      Ember.run.later(function() {
        resolve({ msg: 'Hold Your Horses' });
      }, 3000);
    });
  },

  setupController(controller, model) {
    console.log(model.msg); // "Hold Your Horses"
  }
});
```

При переходе в `route:tardy` будет вызван hook `model()`. Он вернет обещание, которое не разрешится, пока не пройдет 3 секунды. В течение этого времени роутер будет приостановлен на середине перехода. Когда обещание разрешится, роутер продолжит переход и вызовет hook `setupController()` в `route:tardy` с разрешенным объектом.

Такое поведение с паузой на обещании имеет большое значение, когда нужно гарантировать, что данные маршрута полностью загрузятся до отображения нового шаблона.

### Когда обещания завершаются с ошибкой…

Мы рассмотрели случай, когда обещание завершается успешно. Но что если оно завершается с ошибкой?

По умолчанию, если обещание модели во время перехода завершается с ошибкой, переход прерывается, новые шаблоны маршрута назначения не отображаются, и на консоль выводится ошибка.

Можно настроить логику обработки ошибки через обработчика `error` в хеше маршрута `actions`. Когда обещание завершается с ошибкой, на маршруте возникает событие `error`, которое распространяется на исходного обработчика ошибок в `route:application`, если попутно его не встретит индивидуальный обработчик ошибок. Например:

`app/routes/good-for-nothing.js`
```js
export default Ember.Route.extend({
  model() {
    return Ember.RSVP.reject("FAIL");
  },

  actions: {
    error(reason) {
      alert(reason); // "FAIL"

      // Can transition to another route here, e.g.
      // this.transitionTo('index');

      // Uncomment the line below to bubble this error event:
      // return true;
    }
  }
});
```

В примере выше событие ошибки остановится прямо в обработчике ошибок в `route:good-for-nothing` и не распространится дальше. Чтобы событие распространилось дальше на `route:application`, можно вернуть значение true из обработчика ошибок.

### Восстановление после завершения с ошибкой

Завершенные с ошибкой обещания модели удерживают переходы. Но, так как обещания связаны в цепочку, можно перехватить обещания с ошибкой в самом hook `model` и преобразовать их в успешно завершенные, которые не будут задерживать переход.

`app/routes/funky.js`
```js
export default Ember.Route.extend({
  model() {
    return iHopeThisWorks().then(null, function() {
      // Promise rejected, fulfill with some default value to
      // use as the route's model and continue on with the transition
      return { msg: 'Recovered from rejected promise' };
    });
  }
});
```