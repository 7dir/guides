Модели — объекты, которые представляют соответствующие данные. Эти данные приложение показывает пользователю. Разные приложения имеют различные модели в зависимости от проблем, которые они решают.

Например, приложение для обмена фотографиями должно иметь модель `Photo`, чтобы представлять определенную фотографию, и `PhotoAlbum`, чтобы показывать группу фотографий. А приложению для онлайн-магазина понадобятся другие модели вроде `ShoppingCart`, `Invoice`, или `LineItem`.

Модели, как правило, *постоянны*. Это значит, что данные модели не теряются, когда пользователь закрывает окно браузера. Если вы хотите убедиться, что данные не теряются, когда пользователь вносит изменения в модель, вам нужно хранить данные модели там, откуда они не пропадут.

Большинство моделей загружаются и сохраняются через сервер, который использует базу данных для хранения информации. Скорее всего, вы будете посылать JSON-представления модели туда и обратно через написанный вами HTTP-сервер. Но Ember упрощает процесс и позволяет использовать другие надежные хранилища, например, пользовательский жесткий диск с [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) или варианты с удаленным хранением, которые позволяют не писать и не размещать собственные серверы.

Когда вы загрузили модели из хранилища, компоненты переводят данные модели в интерфейс, с которым пользователь может взаимодействовать. Чтобы получить больше информации о том, как компоненты получают данные модели, смотрите раздел [Указание модели маршрута](http://guides.emberjs.com/v2.1.0/routing/specifying-a-routes-model).

Когда вы создаете новое приложение, по умолчанию, вам доступна библиотека Ember Data. Она плотно интегрируется с Ember и упрощает извлечение моделей с сервера в формате JSON, сохранение обновлений на сервере и создание новых моделей в браузере.

Благодаря использованию *шаблона «адаптера»*, Ember Data можно настроить для работы с множеством разных видов backend. Существует целая [экосистема адаптеров](http://emberobserver.com/categories/ember-data-adapters), которая позволяет приложению Ember общаться с разными типами серверов без написания какого-либо сетевого кода.

Если вам нужно интегрировать приложение Ember.js с сервером, который не имеет доступного адаптера (например, вы вручную развернули сервер с API, который не придерживается каких-либо спецификаций JSON), то это не проблема. Ember Data спроектирована так, что ее можно настроить под работу с любыми данными, которые возвращает сервер.

Ember Data также работает с потоковыми серверами вроде тех, что на базе WebSockets. Вы можете открыть сокет для сервера и в любой момент внести изменения в Ember Data. В итоге это дает приложению пользовательский интерфейс, который обновляется в реальном времени.

Сначала может показаться, что использование Ember Data сильно отличается от написания приложений на JavaScript. Многие разработчики знакомы с использованием AJAX для извлечения исходных JSON данных из конечной точки, что поначалу кажется проще. Но со временем код приложения становится запутанным, и его сложно поддерживать.

С Ember Data управление моделями по мере роста приложения становится только проще.

Как только вы поймете суть Ember Data, сможете лучше управлять сложностью данных, загруженных в приложении. Это позволит коду эволюционировать, не превращаясь в неразбериху.

## Хранилище и единый источник достоверных данных

Один из распространенных способов создания веб-приложений — это плотное связывание элементов интерфейса с получением данных. Например, представьте, что вы пишите раздел администратора в приложении для ведения блога. Приложение имеет функцию, которая составляет список заготовок для текущего авторизованного пользователя.

Вы бы для начала сделали компонент, который отвечает за получение этих данных и их хранение:

`app/components/list-of-drafts.js`
```js
export default Ember.Component.extend({
  willRender() {
    $.getJSON('/drafts').then(data => {
      this.set('drafts', data);
    });
  }
});
```

Затем можно показать список заготовок в шаблоне компонента, как здесь:

`app/templates/components/list-of-drafts.hbs`
```hbs
<ul>
  {{#each drafts key="id" as |draft|}}
    <li>{{draft.title}}</li>
  {{/each}}
</ul>
```

Это сработает для компонента `list-of-drafts`. Но приложение состоит из множества разных компонентов. Скажем, на другой странице вам нужен компонент для отображения числа заготовок. Вы явно хотели бы просто скопировать и вставить существующий код `willRender` в новый компонент.

`app/components/drafts-button.js`
```js
export default Ember.Component.extend({
  willRender() {
    $.getJSON('/drafts').then(data => {
      this.set('drafts', data);
    });
  }
});
```

`app/templates/components/drafts-button.hbs`
```hbs
{{#link-to 'drafts' tagName="button"}}
Drafts ({{drafts.length}})
{{/link-to}}
```

К сожалению, теперь приложение будет выполнять два отдельных запроса для одной и той же информации. Не только извлечение избыточных данных приводит к затратам пропускной способности и влияет на скорость работы приложения; два значения проще получить асинхронно. Вы сами, вероятно, использовали веб-приложение, где список элементов извлекался не согласованно со счетчиком в панели инструментов, что приводило к довольно неприятному опыту.

Существует также сильная связанность между интерфейсом пользователя в приложении и сетевым кодом. Если URL или формат полезной нагрузки JSON меняется, это рушит все компоненты интерфейса так, что их сложно отследить.

Принципы хорошего дизайна SOLID указывают, что объекты должны иметь простые обязанности. Обязанность компонента — представление пользователю данных модели без извлечения модели.

Хорошее приложение Ember использует другой подход. Ember Data дает вам единое **хранилище**, которое служит центральным архивом моделей в приложении. Компоненты и маршруты могут запрашивать модели в хранилище, а оно отвечает за их извлечение.

Также хранилище может понять, что два разных компонента запрашивают одну и ту же модель. Это позволяет приложению извлекать данные с сервера только один раз. Вы можете воспринимать хранилище, как выборку кэша для моделей приложения. И компоненты и маршруты имеют доступ к хранилищу; когда им нужно отобразить или видоизменить модель, они сначала обращаются к нему.

## Программирование по соглашениям с JSON API

Вы можете значительно сократить количество кода, необходимого для написания и поддержания, если будете опираться на соглашения Ember. Приняв эти соглашения, вы не только будете писать меньше кода; код станет проще для поддержания и будет понятен другим разработчикам в команде.

Вместо того чтобы создавать произвольный набор соглашений, Ember Data спроектировали для работы с [JSON API](http://www.jsonapi.org/) по умолчанию. JSON API — формальная спецификация для создания общепринятого, надежного и эффективного API, который позволяет клиентам и серверам обмениваться данными модели.

JSON API стандартизирует общение приложений JavaScript с серверами, поэтому вы уменьшаете связанность между frontend и backend и получаете больше свободы в изменении частей стека.

Если провести аналогию, то JSON API для приложений JavaScript — то же самое, что SQL для баз данных и фреймворков на серверной стороне. Популярные фреймворки вроде Ruby on Rails, Laravel, Django, Spring и прочие изначально работают со многими различными базами данных вроде MySQL, PostgreSQL, SQL Server и т. д.

Для фреймворков (или приложений на базе фреймворков) не нужно писать много своего кода, чтобы добавить поддержку для новой базы данных; поскольку эта база данных поддерживает SQL, добавить для нее поддержку довольно просто.

Также и с JSON API. При использовании JSON API для сопряжения приложения Ember с сервером, вы можете полностью изменить стек backend, не нарушая frontend. И как только вы добавите приложения для других платформ вроде iOS и Android, вы сможете выгодно использовать библиотеки JSON API для этих платформ, чтобы с легкостью использовать API, который использует приложение Ember.

## Модели

В Ember Data каждая модель представлена подклассом `Model`, который определяет атрибуты, связи и поведение данных, что будут показаны пользователю.

Модели определяют тип данных, которые предоставит сервер. Например, модель `Person` должна иметь атрибут `firstName` в виде строки, и атрибут `birthday` в виде даты:

`app/models/person.js`
```js
export default DS.Model.extend({
  firstName: DS.attr('string'),
  birthday:  DS.attr('date')
});
```

Модель также описывает ее связи с другими объектами. Например, `order` может иметь много `line-items`, а `line-item` может принадлежать определенному `order`.

`app/models/order.js`
```js
export default DS.Model.extend({
  lineItems: DS.hasMany('line-item')
});
```

`app/models/line-item.js`
```js
export default DS.Model.extend({
  order: DS.belongsTo('order')
});
```

Сами модели не имеют никаких данных; они просто определяют атрибуты, связи и поведение специальных экземпляров, которые называют **записями**.

## Записи

**Запись** — экземпляр модели, которая содержит загруженные с сервера данные. Приложение может также создать новые записи и сохранять их на сервере.

Запись уникальна, и ее определяет **тип** модели и **ID**.

Например, если вы пишите приложение для управления контактами, то должны иметь модель `Person`. Индивидуальная запись в приложении должна иметь тип `person` и ID — `1` или `steve-buscemi`.

```js
this.store.findRecord('person', 1); // => { id: 1, name: 'steve-buscemi' }
```

ID обычно закрепляется за записью сервером, когда вы сохраняете ее в первый раз. Но вы можете генерировать ID на стороне клиента.

## Адаптер

**Адаптер** — объект, который переводит запросы от Ember (например, «найти пользователя с ID - 123») в запросы к серверу.

К примеру, если приложение запрашивает `Person` с ID – `123`, как Ember следует загрузить его? Через HTTP или WebSocket? Если это HTTP, URL будет `/person/1` или `/resources/people/1`?

Обязанность адаптера — отвечать на все эти вопросы. Когда приложение запрашивает у хранилища запись, которую оно не поместило в кэш, оно обращается для этого к адаптеру. Если вы меняете запись и сохраняете ее, хранилище передаст запись адаптеру, чтобы переслать соответствующие данные на сервер и подтвердить, что сохранение прошло успешно.

Адаптеры позволяют полностью изменить реализацию API без воздействия на код приложения Ember.

## Кэширование

Хранилище автоматически сохраняет записи в кэш. Если запись уже была загружена, повторный ее запрос всегда будет возвращать тот же экземпляр объекта. Это минимизирует количество полных обходов сервера и позволяет приложению отображать интерфейс для пользователя так быстро, как это возможно.

Например, когда приложение в первый раз запрашивает у хранилища запись `person` с ID — `1`, хранилище извлечет эту информацию с сервера.

Но в следующий раз, когда приложение запросит `person` с ID — `1`, хранилище сообщит, что эти данные с сервера уже извлечены и сохранены в кэш. Вместо того чтобы отправлять еще один запрос на ту же информацию, хранилище выдаст приложению такую же запись, которую предоставило в первый раз. Эту особенность (всегда возвращать тот же объект записи в независимости от того, сколько раз вы его искали) иногда называют *коллекцией объектов*.

Использование коллекции объектов очень важно, так как это гарантирует, что изменения, которые вы совершили в одной части интерфейса, распространятся на другие части. Еще это значит, что вам не нужно вручную поддерживать синхронизацию записей. Вы можете запросить запись по ID, и другие части приложения также сделают запрос и загрузят ее.

Но есть и один недостаток в возвращении кэшированной записи: вы можете обнаружить, что состояние данных изменилось с момента первой загрузки в коллекцию объектов хранилища. Чтобы избежать этой проблемы, Ember Data будет автоматически делать запрос в фоновом режиме каждый раз, когда кэшированная запись будет возвращаться из хранилища. Когда появятся новые данные, запись обновится, и если с момента изначального отображения данные изменились, шаблон отобразится с учетом новой информации.

## Обзор архитектуры

В первый раз, когда приложение запрашивает у хранилища запись, хранилище проверяет, нет ли локальной копии, и запрашивает ее у адаптера. Адаптер извлечет запись с сохраненного уровня; обычно, это будет JSON-представление записи, которая обслуживается с HTTP-сервера.

![Diagram showing process for finding an unloaded record](/static/img/code/finding-unloaded-record-step1-diagram.png)

Как показано на диаграмме выше, адаптер не всегда может сразу же возвращать запрошенную запись. В этом случае адаптер должен сделать *асинхронный* запрос на сервер, и только когда этот запрос закончит загрузку, запись может быть создана из резервных данных.

Из-за этой асинхронности хранилище сразу возвращает обещание из метода `find()`. Подобным образом любые запросы, с которыми хранилище обращается к адаптеру, также возвращают обещания.

Как только запрос к серверу возвращается с полезной нагрузкой JSON для запрошенной записи, адаптер завершает обещание, которое вернул хранилищу, с помощью JSON.

Тогда хранилище забирает этот JSON, инициализирует запись с данными JSON и завершает обещание, возвращенное приложению, вновь-загруженной записью.

![Diagram showing process for finding an unloaded record after the payload has returned from the server](/static/img/code/finding-unloaded-record-step2-diagram.png)

Давайте взглянем, что происходит, если вы запрашиваете запись, которую хранилище уже отправило в кэш.

![Diagram showing process for finding an unloaded record after the payload has returned from the server](/static/img/code/finding-loaded-record-diagram.png)

В таком случае хранилище уже знает о записи и возвращает обещание, которое сразу же завершает записью. Нет нужды запрашивать у адаптера (и тем более сервера) копию, так как она уже сохранена локально.

---

Модели, записи, адаптеры и хранилище — ключевые концепции, которые вам следует понимать, чтобы получить максимум от использования Ember Data. В следующих разделах более подробно рассматривается каждая из этих концепций и принцип их совместного использования.